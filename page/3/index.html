<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&family=Roboto+Mono:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"misakatang.cn","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.22.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12,"onmobile":false},"hljswrap":true,"copycode":{"enable":true,"style":null,"show_result":false},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="The limits of my language are the limits of my world">
<meta property="og:type" content="website">
<meta property="og:title" content="MisakaTang&#39;s Blog">
<meta property="og:url" content="http://misakatang.cn/page/3/index.html">
<meta property="og:site_name" content="MisakaTang&#39;s Blog">
<meta property="og:description" content="The limits of my language are the limits of my world">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="MisakaTang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://misakatang.cn/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MisakaTang's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4TSLH4NC9H"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-4TSLH4NC9H","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?de7c77febeeac252eee468207ae11ce4"></script>



  <script>
    (function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
    })(window, document, "clarity", "script", "jtb4czrfeu");
</script>


  <script async defer data-website-id="b9e21e4f-5512-43e5-ab60-01a527a98a8c" src="https://umami-kappa-cyan.vercel.app/script.js" data-host-url="https://umami-kappa-cyan.vercel.app"></script>


  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="MisakaTang's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">MisakaTang's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="MisakaTang"
      src="/images/misaka.jpg">
  <p class="site-author-name" itemprop="name">MisakaTang</p>
  <div class="site-description" itemprop="description">The limits of my language are the limits of my world</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/%E5%BD%92%E6%A1%A3/">
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">104</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/TangMisaka23001" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;TangMisaka23001" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mikasatang@gmail.com" title="E-Mail → mailto:mikasatang@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="http://blog.bbchen.top/" title="http:&#x2F;&#x2F;blog.bbchen.top" rel="noopener" target="_blank">BB chen的漂流记</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://blog.zhuzhenyuan.cn/" title="http:&#x2F;&#x2F;blog.zhuzhenyuan.cn" rel="noopener" target="_blank">Aurthur_的博客</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2024/07/15/programming-language-pragmatics-08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/15/programming-language-pragmatics-08/" class="post-title-link" itemprop="url">《Programming Language Pragmatics》第八章笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-15 11:45:14" itemprop="dateCreated datePublished" datetime="2024-07-15T11:45:14+00:00">2024-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-04 03:05:07" itemprop="dateModified" datetime="2025-01-04T03:05:07+00:00">2025-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Subroutines-and-Control-Abstraction"><a href="#Subroutines-and-Control-Abstraction" class="headerlink" title="Subroutines and Control Abstraction"></a>Subroutines and Control Abstraction</h2><p>Subroutines are the principal mechanism for control abstraction in most programming languages.</p>
<ul>
<li>A subroutine that returns a value is usually called a <em>function</em>.</li>
<li>A subroutine that does not return a value is usually called a <em>procedure</em>.</li>
</ul>
<h3 id="Review-of-Stack-Layout（栈内存布局）"><a href="#Review-of-Stack-Layout（栈内存布局）" class="headerlink" title="Review of Stack Layout（栈内存布局）"></a>Review of Stack Layout（栈内存布局）</h3><p>the <strong>stack pointer</strong> register contains the address of either the last used location at the top of the stack, or the first unused location</p>
<p>The <strong>frame pointer</strong> register contains an address within the frame.</p>
<h3 id="Calling-Sequences"><a href="#Calling-Sequences" class="headerlink" title="Calling Sequences"></a>Calling Sequences</h3><p>Maintenance of the subroutine call stack is the responsibility of the calling sequence</p>
<p>Tasks that must be accomplished on the way <strong>into</strong> a subroutine include：</p>
<ul>
<li>passing parameters</li>
<li>saving the return address</li>
<li>changing the program counter</li>
<li>changing the stack pointer to allocate space</li>
<li>saving registers (including the frame pointer) that contain important values and that may be overwritten by the callee</li>
<li>changing the frame pointer to refer to the new frame</li>
<li>executing initialization code for any objects in the new frame that require it</li>
</ul>
<p>Tasks that must be accomplished on the way <strong>out</strong> include：</p>
<ul>
<li>passing return parameters or function values</li>
<li>executing finalization code for any local objects that require it</li>
<li>deallocating the stack frame (restoring the stack pointer)</li>
<li>restoring other saved registers (including the frame pointer)</li>
<li>restoring the program counter</li>
</ul>
<h5 id="Saving-and-Restoring-Registers"><a href="#Saving-and-Restoring-Registers" class="headerlink" title="Saving and Restoring Registers"></a>Saving and Restoring Registers</h5><p>函数调用最棘手的部分就是保存和恢复寄存器。</p>
<blockquote>
<p>Perhaps the trickiest division-of-labor issue pertains to saving registers. </p>
</blockquote>
<p>A <em>simpler solution</em> is for the caller to save all registers that are in use, or for the callee to save all registers that it will overwrite.</p>
<p>调用约定：</p>
<p>strike something of a compromise: registers not reserved for special purposes are divided into two sets of approximately equal size. One set is the caller’s responsibility, the other is the callee’s responsibility. A callee can assume that there is nothing of value in any of the registers in the caller-saves set; a caller can assume that no callee will destroy the contents of any registers in the callee-saves set.</p>
<h5 id="Maintaining-the-Static-Chain"><a href="#Maintaining-the-Static-Chain" class="headerlink" title="Maintaining the Static Chain"></a>Maintaining the Static Chain</h5><p>In languages with nested subroutines,at least part of the work required to maintain the static chain must be performed by the caller,rather than the callee,because this work depends on the lexical nesting depth of the caller. </p>
<h5 id="A-Typical-Calling-Sequence"><a href="#A-Typical-Calling-Sequence" class="headerlink" title="A Typical Calling Sequence"></a>A Typical Calling Sequence</h5><p>The caller：</p>
<ol>
<li>saves any caller-saves registers whose values will be needed after the call</li>
<li>computes the values of arguments and moves them into the stack or registers</li>
<li>computes the static link (if this is a language with nested subroutines), and passes it as an extra, hidden argument</li>
<li>uses a special subroutine call instruction to jump to the subroutine, simultaneously passing the return address on the stack or in a register</li>
</ol>
<p>the callee：</p>
<ol>
<li>allocates a frame by subtracting an appropriate constant from the sp</li>
<li>saves the old frame pointer into the stack, and assigns it an appropriate new value</li>
<li>saves any callee-saves registers that may be overwritten by the current routine (including the static link and return address, if they were passed in registers)</li>
</ol>
<p>After the subroutine has completed, the epilogue：</p>
<ol>
<li>moves the return value (if any) into a register or a reserved location in the stack</li>
<li>restores callee-saves registers if needed</li>
<li>restores the fp and the sp</li>
<li>jumps back to the return address</li>
</ol>
<p>Finally, the caller：</p>
<ol>
<li>moves the return value to wherever it is needed</li>
<li>restores caller-saves registers if needed</li>
</ol>
<h4 id="Displays"><a href="#Displays" class="headerlink" title="Displays"></a>Displays</h4><p>One disadvantage of static chains is that access to an object in a scope k levels out requires that the static chain be dereferenced k times.</p>
<p>This number can be reduced to a constant by use of a display.</p>
<blockquote>
<p>为了优化这一过程，可以引入一个叫做 display 的数据结构。display 是一个数组，其中的每个元素都是一个指针，指向不同嵌套层级的活动记录（activation record）。当进入一个函数时，编译器会更新 display 来反映当前的调用环境。具体来说，display[i] 会指向第 i 层嵌套的最近活动记录。</p>
<p>使用 display 可以直接通过数组索引快速定位到任何层级的活动记录，从而让访问外层变量的操作更加高效。这种方法减少了通过多个静态链指针进行跳转的需要，因此可以显著提高程序的运行速度，尤其是在函数嵌套层次较深的情况下。</p>
</blockquote>
<h4 id="Case-Studies-C-on-the-MIPS-Pascal-on-the-x86"><a href="#Case-Studies-C-on-the-MIPS-Pascal-on-the-x86" class="headerlink" title="Case Studies: C on the MIPS; Pascal on the x86"></a>Case Studies: C on the MIPS; Pascal on the x86</h4><p>Calling sequences <strong>differ significantly</strong> from machine to machine and even compiler tocompiler</p>
<ul>
<li>Compilers for CISC machines tend to pass arguments on the stack; compilers for RISC machines tend to pass arguments in registers.</li>
<li>Compilers for CISC machines usually dedicate a register to the frame pointer; compilers for RISC machines often do not.</li>
<li>Compilers for CISC machines often rely on special-purpose instructions to implement parts of the calling sequence; available instructions on a RISC machine are typically much simpler.</li>
</ul>
<h4 id="Register-Windows"><a href="#Register-Windows" class="headerlink" title="Register Windows"></a>Register Windows</h4><p>As an alternative to saving and restoring registers on subroutine calls and returns, the original Berkeley RISC machines introduced a <em>hardware mechanism</em> known as <strong>register windows</strong>. </p>
<p>The basic idea is to <em>map</em> the ISA’s limited set of register names onto some subset (window) of a much larger collection of physical registers, and to change the mapping when making subroutine calls.</p>
<h4 id="In-Line-Expansion"><a href="#In-Line-Expansion" class="headerlink" title="In-Line Expansion"></a>In-Line Expansion</h4><p>many language implementations allow certain subroutines to be <em>expanded in-line</em> at the point of call：</p>
<blockquote>
<p>A copy of the “called” routine becomes a part of the “caller”; no actual subroutine calloccurs.</p>
</blockquote>
<p>In-line expansion avoids a variety of overheads,including:</p>
<ul>
<li>space allocation, </li>
<li>branch delays from the call and return, </li>
<li>maintaining the static chain or display, </li>
<li>and (often) saving and restoring registers.</li>
</ul>
<p>It also allows the compiler to perform <em>code improvements</em> such as:</p>
<ul>
<li>global register allocation</li>
<li>instruction scheduling</li>
<li>common subexpression elimination across the boundaries between subroutines</li>
</ul>
<h3 id="Parameter-Passing"><a href="#Parameter-Passing" class="headerlink" title="Parameter Passing"></a>Parameter Passing</h3><p>Most subroutines are parameterized: they take arguments that control certain aspects of their behavior, or specify the data on which they are to operate.</p>
<p>Parameter names that appear in the declaration of a subroutine are known as <strong>formal parameters</strong>. </p>
<p>Variables and expressions that are passed to a subroutine in a particular call are known as <strong>actual parameters</strong>. </p>
<h4 id="Parameter-Modes"><a href="#Parameter-Modes" class="headerlink" title="Parameter Modes"></a>Parameter Modes</h4><p>The two most common parameter-passing modes, called：</p>
<ul>
<li>call-by-value</li>
<li>call-by-reference</li>
</ul>
<p>call-by-value只要在函数返回时把参数的值写回到调用方，就可以实现和call-by-reference类似的效果</p>
<h5 id="Call-by-sharing"><a href="#Call-by-sharing" class="headerlink" title="Call-by-sharing"></a>Call-by-sharing</h5><p>不是值传递。因为：</p>
<blockquote>
<p>if we modify the object to which the formal parameter refers, the program will be able to see those changes through the actual parameter after the subroutine returns</p>
</blockquote>
<p>也不是引用传递，因为：</p>
<blockquote>
<p>although the called routine can change the value of the object to which the actual parameter refers, it cannot change the identity of that object.</p>
</blockquote>
<p>Call-by-sharing is thus commonly implemented the same as call-by-value for objects of immutable type.</p>
<h5 id="The-Purpose-of-Call-by-Reference"><a href="#The-Purpose-of-Call-by-Reference" class="headerlink" title="The Purpose of Call-by-Reference"></a>The Purpose of Call-by-Reference</h5><ul>
<li>需要修改参数</li>
<li>传递地址比复制参数节约时间</li>
</ul>
<h4 id="Call-by-Name"><a href="#Call-by-Name" class="headerlink" title="Call-by-Name"></a>Call-by-Name</h4><p>Explicit subroutine parameters are not the only language feature that requires a closure to be passed as a parameter. </p>
<p>In general, a language implementation must pass a closure whenever the eventual use of the parameter requires the <strong>restoration of a previous referencing environment</strong>. </p>
<h4 id="Special-Purpose-Parameters"><a href="#Special-Purpose-Parameters" class="headerlink" title="Special-Purpose Parameters"></a>Special-Purpose Parameters</h4><ul>
<li>Conformant Arrays</li>
<li>Default (Optional) Parameters</li>
<li>Named Parameters: A(name&#x3D;’xxx’, age&#x3D;24)</li>
<li>Variable Numbers of Arguments: fun(string…)</li>
</ul>
<h3 id="Generic-Subroutines-and-Modules"><a href="#Generic-Subroutines-and-Modules" class="headerlink" title="Generic Subroutines and Modules"></a>Generic Subroutines and Modules</h3><p>需要泛型的原因：</p>
<blockquote>
<p>In a language like Pascal or Fortran, this static declaration of item type means that the programmer must create separate <strong>copies</strong> of enqueue and dequeue <strong>for every type of item</strong>, even though the entire text of these copies (other than the type names in the procedure headers) is the same.</p>
</blockquote>
<h4 id="Implementation-Options"><a href="#Implementation-Options" class="headerlink" title="Implementation Options"></a>Implementation Options</h4><p>Generics can be implemented several ways.</p>
<ul>
<li>the compiler creates a <strong>separate copy</strong> of the code for every instance</li>
<li>guarantees that all instances of a given generic will <strong>share the same code</strong> at run time.</li>
</ul>
<h4 id="Generic-Parameter-Constraints（泛型约束）"><a href="#Generic-Parameter-Constraints（泛型约束）" class="headerlink" title="Generic Parameter Constraints（泛型约束）"></a>Generic Parameter Constraints（泛型约束）</h4><p>避免使用隐式泛型参数:</p>
<blockquote>
<p>To avoid surprises, it is best to avoid implicit use of the operations of a generic parameter type. </p>
</blockquote>
<h3 id="Exception-Handling"><a href="#Exception-Handling" class="headerlink" title="Exception Handling"></a>Exception Handling</h3><p>exception handling generally requires the language implementation to “unwind” the subroutine call stack.</p>
<p>try catch语法：</p>
<blockquote>
<p>all provide exception-handling facilities in which handlers are lexically bound to blocks of code, and in which the execution of the handler replaces the yet-to-be-completed portion of the block.</p>
</blockquote>
<p>In practice, exception handlers tend to perform three kinds of operations:</p>
<ul>
<li>First, ideally, a handler will compensate for the exception in a way that allows the program to recover and continue execution. </li>
<li>Second, when an exception occurs in a given block of code but cannot be handled locally, it is often important to declare a local handler that cleans up any resources allocated in the local block, and then “reraises”the exception, so that it will continue to propagate back to a handler that can (hopefully) recover.</li>
<li>Third, if recovery is not possible, a handler can at least print a helpful error message before the program terminates.</li>
</ul>
<h4 id="Defining-Exceptions"><a href="#Defining-Exceptions" class="headerlink" title="Defining Exceptions"></a>Defining Exceptions</h4><p>In many languages, dynamic semantic errors automatically result in exceptions, which the program can then catch. The programmer can also define additional, application-specific exceptions.</p>
<p>Most languages use a throw or raise statement,embedded in an if statement, to raise an exception at run time. </p>
<p>已知和未知异常：</p>
<p>If a subroutine raises an exception but does not catch it internally, it may “return” in an unexpected way. </p>
<p>include in each subroutine header a list of the exceptions that may propagate out of the routine. </p>
<p><em>Unchecked exceptions</em> are typically run-time errors that most programs will want to be fatal</p>
<h4 id="Exception-Propagation（异常传播）"><a href="#Exception-Propagation（异常传播）" class="headerlink" title="Exception Propagation（异常传播）"></a>Exception Propagation（异常传播）</h4><p>When an exception arises, the handlers are examined in order; control is transferred to the first one that matches the exception. </p>
<h4 id="Implementation-of-Exceptions"><a href="#Implementation-of-Exceptions" class="headerlink" title="Implementation of Exceptions"></a>Implementation of Exceptions</h4><p>The most obvious implementation for exceptions maintains a linked-list stack of handlers. When control enters a protected block, the handler for that block is added to the head of the list.</p>
<h3 id="Coroutines"><a href="#Coroutines" class="headerlink" title="Coroutines"></a>Coroutines</h3><p>vs continuation：</p>
<blockquote>
<p>a <em>continuation</em> is a constant—it does not change once created—while a <em>coroutine</em> changes every time it runs.</p>
</blockquote>
<p>coroutines are execution contexts that exist concurrently, but that execute one at a time, and that transfer control to each other explicitly, by name. Coroutines can be used to implement iterators and threads. </p>
<h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><p>An event is something to which a running program (a process) needs to respond, but which occurs outside the program, at an unpredictable time. </p>
<p>事件和回调：</p>
<p>Instead, the programmer usually wants a handler—a special subroutine—to be invoked when a given event occurs. Handlers are sometimes known as callback functions,because the run-time system calls back into the main program instead of being called from it.</p>
<h3 id="Summary-and-Concluding-Remarks"><a href="#Summary-and-Concluding-Remarks" class="headerlink" title="Summary and Concluding Remarks"></a>Summary and Concluding Remarks</h3><p>这一章主要关注了控制抽象的主题，特别是子程序。子程序允许程序员将代码封装在一个狭窄的接口后面，然后可以不考虑其实现方式进行使用。控制抽象对于任何大型软件系统的设计和维护都至关重要。从审美的角度来看，像Lisp和Smalltalk这样的语言中，内置和用户定义的控制结构使用相同的语法，这使得控制抽象特别有效。</p>
<p>我们在8.1节开始研究子程序，首先回顾了子程序调用堆栈的管理。然后我们考虑了用于维护堆栈的调用序列，PLP CD的额外部分专门讨论了展示；MIPSpro C编译器和GNU x86 Pascal编译器（gpc）的案例研究；以及SPARC的寄存器窗口。在简要考虑内联扩展之后，我们在8.3节转向了参数的主题。我们首先考虑了参数传递模式，所有这些模式都是通过传递值、引用或闭包来实现的。我们注意到，语义清晰和实现速度的目标有时会有冲突：通常通过引用传递大参数最有效，但是由此产生的别名可能会导致程序错误。在8.3.3节，我们考虑了特殊的参数传递机制，包括一致的数组、默认（可选）参数、命名参数和可变长度的参数列表。我们注意到，默认和命名参数提供了一种对动态范围的有吸引力的替代方案。在8.4节，我们考虑了泛型子程序和模块的设计和实现。泛型允许在编译时将控制抽象参数化，以参数的类型而不仅仅是它们的值为基础。</p>
<p>在最后的三个主要部分，我们考虑了异常处理机制，这些机制允许程序以良好的结构方式从嵌套的子程序调用序列中“解开”；协程，它允许程序维护（并在两个或更多执行上下文之间切换）；以及事件，它允许程序响应异步外部活动。在PLP CD上，我们解释了协程如何用于离散事件模拟。我们还注意到，它们可以用来实现迭代器，但在这里存在更简单的替代方案。在第12章，我们将基于协程来实现线程，这些线程并行运行（或看起来并行运行）。</p>
<p>在几个情况下，我们可以看出关于语言应该提供哪些类型的控制抽象的观点正在形成共识。像Fortran和Algol 60这样的语言的有限参数传递模式已被更广泛或灵活的选项取代。Ada和C++等语言中，标准的位置记号法已被默认参数和命名参数所增强。较少结构化的错误处理机制，如标签参数、非局部goto和动态绑定处理器，已被结构化的异常处理器取代，这些异常处理器在子程序内部进行词法范围处理，并且在常见（无异常）情况下可以零成本实现。传统的信号处理机制中的自发子程序调用已被专用线程中的回调取代。在许多情况下，实现这些新特性需要编译器和运行时系统变得更复杂。偶尔，如call-by-name参数、标签参数或非局部goto的情况，语义上令人困惑的特性也难以实现，放弃它们使编译器变得更简单。在其他情况下，一些有用但难以实现的语言特性仍然在一些语言中出现，但在其他语言中则不出现。这一类别的例子包括一等子程序、协程、迭代器、续延和具有无限范围的局部对象。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2024/07/10/programming-language-pragmatics-07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/10/programming-language-pragmatics-07/" class="post-title-link" itemprop="url">《Programming Language Pragmatics》第七章笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-10 11:45:14" itemprop="dateCreated datePublished" datetime="2024-07-10T11:45:14+00:00">2024-07-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-04 03:05:07" itemprop="dateModified" datetime="2025-01-04T03:05:07+00:00">2025-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="DataTypes"><a href="#DataTypes" class="headerlink" title="DataTypes"></a>DataTypes</h2><p>Types serve two principal purposes:</p>
<ul>
<li>Types provide implicit context for many operations, so that the programmer does not have to specify that context explicitly. 让编译器知道是整数还是浮点数加减、自定义类型申请正确的堆空间、执行用户自定义的类型构造器（constructor）</li>
<li>Types limit the set of operations that may be performed in a semantically valid program.</li>
</ul>
<h3 id="Type-Systems"><a href="#Type-Systems" class="headerlink" title="Type Systems"></a>Type Systems</h3><p>硬件层面所有bit没有区别：</p>
<blockquote>
<p>Computer hardware can <strong>interpret bits in memory in several different ways</strong>: as instructions, addresses, characters, and integer and floating-point numbers of various lengths. </p>
</blockquote>
<p>高级语言必须使用类型系统来提供某一块bit的类型上下文信息和错误检查（整数加浮点数。。。）</p>
<blockquote>
<p>High-level languages, on the other hand, almost always associate types with values, to provide the contextual information and error checking alluded to above.</p>
</blockquote>
<p>a type system consists：</p>
<ul>
<li>a mechanism to define types and associate them with certain language constructs</li>
<li>a set of rules for type equivalence, type compatibility, and type inference.</li>
</ul>
<h4 id="Type-Checking"><a href="#Type-Checking" class="headerlink" title="Type Checking"></a>Type Checking</h4><p>Type checking is the process of ensuring that a program obeys the language’s type compatibility rules.</p>
<p>几种分类：</p>
<ul>
<li>强类型</li>
<li>弱类型</li>
<li>静态类型</li>
<li>动态类型</li>
<li>编译时绑定</li>
<li>运行时绑定</li>
</ul>
<h4 id="Polymorphism（多态）"><a href="#Polymorphism（多态）" class="headerlink" title="Polymorphism（多态）"></a>Polymorphism（多态）</h4><p>Polymorphism allows a single body of code to work with objects of multiple types.</p>
<p>多态、动态类型会造成运行时消耗并且延迟暴露类型错误</p>
<p>explicit parametric polymorphism（泛型）</p>
<h4 id="The-Meaning-of-“Type”"><a href="#The-Meaning-of-“Type”" class="headerlink" title="The Meaning of “Type”"></a>The Meaning of “Type”</h4><p>There are at least three ways to think about types, which we may call the <em>denotational</em>, <em>constructive</em>, and <em>abstraction-based</em> points of view. </p>
<ul>
<li>denotational（表示意义）：A value has a given type if it belongs to the set</li>
<li>constructive（构造）：a type is either one of a small collection of built-in types, or a composite type created by applying a type constructor </li>
<li>abstraction-based（基于抽象）：a type is an interface consisting of a set of operations with well-defined and mutually consistent semantics</li>
</ul>
<p><strong>Types are domains</strong>, and the meaning of an expression is a value from the domain that represents the expression’s type. </p>
<p>One of the nice things about the denotational view of types is that it allows us in many cases to describe user-defined composite types.</p>
<h4 id="Classification-of-Types"><a href="#Classification-of-Types" class="headerlink" title="Classification of Types"></a>Classification of Types</h4><p>Most languages provide built-in types similar to those <strong>supported in hardware</strong> by most processors: integers, characters, Booleans, and real (floating-point) numbers.</p>
<ul>
<li>Numeric Types</li>
<li>Enumeration Types</li>
<li>Subrange Types: 0..100</li>
<li>Composite Types<ul>
<li>Records (structures) </li>
<li>Variant records (unions)</li>
<li>Arrays</li>
<li>Sets</li>
<li>Pointers</li>
<li>Lists</li>
<li>Files</li>
</ul>
</li>
</ul>
<h4 id="Orthogonality（正交性）"><a href="#Orthogonality（正交性）" class="headerlink" title="Orthogonality（正交性）"></a>Orthogonality（正交性）</h4><p>Orthogonality is equally important in type system design. A highly orthogonal language tends to be easier to understand, to use, and to reason about in a formal way. </p>
<h3 id="Type-Checking-1"><a href="#Type-Checking-1" class="headerlink" title="Type Checking"></a>Type Checking</h3><h4 id="Type-Equivalence"><a href="#Type-Equivalence" class="headerlink" title="Type Equivalence"></a>Type Equivalence</h4><p>there are two principal ways of defining type equivalence. </p>
<ul>
<li>Structural equivalence is based on the content of type definitions（结构一样就一样）</li>
<li>Name equivalence is based on the lexical occurrence of type definitions（结构一样换个名字也不一样）</li>
</ul>
<h4 id="Type-Compatibility"><a href="#Type-Compatibility" class="headerlink" title="Type Compatibility"></a>Type Compatibility</h4><p>Most languages do not require equivalence of types in every context. Instead, they merely say that a value’s type must be <strong>compatible</strong> with that of the context in which it appears.</p>
<p>In general, modern compiled languages display a trend toward static typing and away from type coercion.</p>
<p>For systems programming,or to facilitate the writing of general-purpose container (collection) objects (lists, stacks, queues, sets, etc.) that hold references to other objects, several languages provide a universal reference type. </p>
<h3 id="Records-Structures-and-Variants-Unions"><a href="#Records-Structures-and-Variants-Unions" class="headerlink" title="Records (Structures) and Variants (Unions)"></a>Records (Structures) and Variants (Unions)</h3><p>Record types allow related data of heterogeneous types to be stored and manipulated together.</p>
<h4 id="Memory-Layout-and-Its-Impact"><a href="#Memory-Layout-and-Its-Impact" class="headerlink" title="Memory Layout and Its Impact"></a>Memory Layout and Its Impact</h4><p>The fields of a record are usually stored in adjacent locations in memory. In its symbol table,the compiler keeps track of the <strong>offset</strong> of each field within each record type.</p>
<h4 id="Variant-Records-Unions"><a href="#Variant-Records-Unions" class="headerlink" title="Variant Records (Unions)"></a>Variant Records (Unions)</h4><p>Many allowed the programmer to specify that certain variables (presumably ones that would never be used at the same time) should be allocated “on top of” one another, <em>sharing the same bytes in memory</em>.</p>
<h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>Arrays are the most common and important composite data types. They have been a fundamental part of almost every high-level language.</p>
<p>接下来的章节包含下面的内容：</p>
<ul>
<li>Syntax and Operations</li>
<li>Dimensions, Bounds, and Allocation<ul>
<li>Stack Allocation</li>
<li>Heap Allocation</li>
</ul>
</li>
<li>Memory Layout<ul>
<li>row-major</li>
<li>column-major</li>
<li>Row-Pointer Layout</li>
<li>Address Calculations</li>
</ul>
</li>
</ul>
<h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><h3 id="Pointers-and-RecursiveTypes"><a href="#Pointers-and-RecursiveTypes" class="headerlink" title="Pointers and RecursiveTypes"></a>Pointers and RecursiveTypes</h3><ul>
<li>Dangling References</li>
<li>Garbage Collection<ul>
<li>Reference Counts</li>
<li>Tracing Collection</li>
<li>Mark-and-Sweep</li>
<li>Pointer Reversal</li>
<li>Stop-and-Copy</li>
<li>Generational Collection</li>
<li>Conservative Collection</li>
</ul>
</li>
</ul>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><h3 id="Files-and-Input-Output"><a href="#Files-and-Input-Output" class="headerlink" title="Files and Input&#x2F;Output"></a>Files and Input&#x2F;Output</h3><h3 id="EqualityTesting-and-Assignment"><a href="#EqualityTesting-and-Assignment" class="headerlink" title="EqualityTesting and Assignment"></a>EqualityTesting and Assignment</h3><h3 id="Summary-and-Concluding-Remarks"><a href="#Summary-and-Concluding-Remarks" class="headerlink" title="Summary and Concluding Remarks"></a>Summary and Concluding Remarks</h3><p>这一节结束了我们关于语言设计五个核心章节中的第三章（第一部分的名称、控制流、类型、子程序和类）。在前两节中，我们讨论了类型系统和类型检查的一般问题。在剩余的章节中，我们检查了最重要的复合类型：记录和变体、数组和字符串、集合、指针和递归类型、列表和文件。我们注意到类型有两个主要目的：它们为许多操作提供了隐式上下文，使程序员无需明确指定该上下文，并且它们允许编译器捕捉各种常见的编程错误。类型系统包括一组内置类型、定义新类型的机制以及类型等价、类型兼容性和类型推断的规则。类型等价确定两个名称或值何时具有相同的类型。类型兼容性确定何时可以在“期望”另一类型的上下文中使用某一类型的值。类型推断基于其组件的类型或（有时）周围上下文来确定表达式的类型。如果一个语言从不允许对不支持它的对象进行操作，则称该语言为强类型语言；如果一个语言在编译时强制执行强类型，则称该语言为静态类型语言。</p>
<p>在我们关于类型的一般讨论中，我们区分了表示性、构造性和基于抽象的观点，分别从它们的值、它们的子结构以及它们支持的操作来看待类型。我们为常见的内置类型、枚举、子范围以及常见的类型构造器引入了术语。我们讨论了几种不同的类型等价、兼容性和推断方法，包括（在PLP CD上）对ML的推断规则的详细检查。我们还检查了类型转换、强制和非转换类型转换。在类型等价的领域内，我们对比了结构性和基于名称的方法，指出虽然名称等价似乎越来越受欢迎，但结构等价仍有其拥护者。</p>
<p>在我们对复合类型的调查中，我们花了最多的时间在记录、数组和递归类型上。记录的关键问题包括变体记录的语法和语义、整个记录的操作、类型安全以及每个与内存布局的交互。内存布局对数组也很重要，在其中它与形状的绑定时间相互作用；静态、栈和基于堆的分配策略；数值应用中高效的数组遍历；C中指针和数组的互操作性；以及可用的整个数组和基于切片的操作集。</p>
<p>对于递归数据类型，很多都取决于变量&#x2F;名称的值模型和引用模型之间的选择。递归类型是引用模型的自然结果；使用值模型时，它们需要指针的概念：其值为引用的变量。从实现角度来看，值与引用之间的区别很重要：将内置类型实现为引用是浪费的，因此具有引用模型的语言通常会以不同方式实现内置和用户定义的类型。Java在语言语义中反映了这种区别，要求内置类型采用值模型，用户定义的类类型的对象采用引用模型。</p>
<p>递归类型通常用于创建链接数据结构。在大多数情况下，这些结构必须从堆中分配。在一些语言中，程序员负责释放不再需要的堆对象。在其他语言中，语言运行时系统自动识别并回收这种垃圾。显式释放是对程序员的一种负担，并会导致内存泄漏和悬挂引用的问题。尽管语言实现几乎从不尝试捕捉内存泄漏（参见探索3.32和练习7.36，不过，有一些关于这个主题的想法），但有时会使用墓碑或锁和钥匙来捕捉悬挂引用。自动垃圾回收可能代价高昂，但已被证明越来越受欢迎。大多数垃圾回收技术要么依赖于引用计数，要么依赖于某种形式的递归探索（追踪）当前可访问的结构。这一类别中的技术包括标记-清扫、停止-复制和分代收集。</p>
<p>语言设计的几个领域中，I&#x2F;O显示出了极大的变化。我们的讨论（主要在PLP CD上）区分了交互式I&#x2F;O，这往往非常具有平台特定性，以及基于文件的I&#x2F;O，后者又细分为临时文件，用于单次程序运行中的大量数据，以及用于离线存储的持久文件。文件还细分为那些以二进制形式表示信息的文件，这些文件模仿内存中的布局，以及那些转换为字符基础文本和从字符基础文本转换回来的文件。与二进制文件相比，文本文件通常会产生时间和空间的开销，但它们具有可移植性和人类可读性的重要优势。</p>
<p>在我们对类型的检查中，我们看到了许多语言创新的例子，这些创新有助于提高程序的清晰度和可维护性，而且通常几乎没有或根本没有性能开销。例子包括用户定义类型的原始想法（Algol 68）、枚举和子范围类型（Pascal）、记录和变体的整合（Pascal）以及Ada中子类型和派生类型之间的区别。在第9章中，我们将检查许多人认为过去30年中最重要的创新，即面向对象。</p>
<p>在某些情况下，语言之间的区别不太是进化的问题，而是哲学上的根本差异。我们已经提到了变量&#x2F;名称的值模型和引用模型之间的选择。同样地，大多数语言采用了静态类型，但Smalltalk、Lisp和许多脚本语言则与动态类型配合得很好。大多数静态类型语言采用了名称等价，但ML和Modula-3则与结构等价配合得很好。大多数语言已经远离了类型强制转换，但C++却接受了它们：结合运算符重载，它们使得在语言本身之外定义简洁、类型安全的I&#x2F;O例程成为可能。</p>
<p>正如上一章中所看到的，为了简化编译器，或使编译后的程序更小或更快，一种语言的便利性、正交性或类型安全似乎已经受到了妥协。例子包括大多数语言中缺乏对记录的相等性测试，Pascal和Ada要求记录的变体部分位于末尾的要求，许多语言对集合最大尺寸的限制，C语言中缺乏对I&#x2F;O的类型检查，以及许多语言实现中通常缺乏动态语义检查。我们还看到了几个至少部分是为了高效实现而引入的语言特性的例子。这些包括打包类型、多长度数值类型、with语句、十进制算术和C风格的指针算术。</p>
<p>与此同时，可以看出语言设计者和用户越来越愿意接受语言实现中的复杂性和成本，以改善语义。这里的例子包括Ada的类型安全变体记录；Java和C#的标准长度数值类型；Icon、Java和C#的变长字符串和字符串操作符；Ada中数组边界的后期绑定；以及Fortran 90中丰富的整个数组和基于切片的数组操作。也可以包括ML的多态类型推断。当然，还应该包括自动垃圾回收的趋势。曾经被认为对于生产质量的命令式语言来说太昂贵的垃圾回收，现在不仅在Clu和Cedar等实验性语言中是标准配置，而且在Ada、Modula-3、Java和C#中也是如此。许多这样的特性，包括变长字符串、切片和垃圾回收，已被脚本语言所采纳。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://misakatang.cn/2024/07/09/programming-language-pragmatics-06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/misaka.jpg">
      <meta itemprop="name" content="MisakaTang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MisakaTang's Blog">
      <meta itemprop="description" content="The limits of my language are the limits of my world">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | MisakaTang's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/09/programming-language-pragmatics-06/" class="post-title-link" itemprop="url">《Programming Language Pragmatics》第六章笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-09 11:45:14" itemprop="dateCreated datePublished" datetime="2024-07-09T11:45:14+00:00">2024-07-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-01-04 03:05:07" itemprop="dateModified" datetime="2025-01-04T03:05:07+00:00">2025-01-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/%E5%88%86%E7%B1%BB/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Control-Flow"><a href="#Control-Flow" class="headerlink" title="Control Flow"></a>Control Flow</h2><p>the language mechanisms used to specify ordering into several categories:</p>
<ul>
<li>Sequencing</li>
<li>Selection</li>
<li>Iteration</li>
<li>Procedural abstraction</li>
<li>Recursion</li>
<li>Concurrency</li>
<li>Exception handling and speculation</li>
<li>Nondeterminacy</li>
</ul>
<h3 id="Expression-Evaluation"><a href="#Expression-Evaluation" class="headerlink" title="Expression Evaluation"></a>Expression Evaluation</h3><p>An expression generally consists of either a simple object (e.g., a literal constant, or a named variable or constant) or an operator or function applied to a collection of operands or arguments, each of which in turn is an expression. </p>
<h4 id="Precedence-and-Associativity"><a href="#Precedence-and-Associativity" class="headerlink" title="Precedence and Associativity"></a>Precedence and Associativity</h4><p>运算符的优先级和结合性</p>
<h4 id="Assignments"><a href="#Assignments" class="headerlink" title="Assignments"></a>Assignments</h4><p>computation typically consists of an ordered series of changes to the values of variables in memory. <strong>Assignments</strong> provide the principal means by which to make the changes.</p>
<h5 id="side-effect"><a href="#side-effect" class="headerlink" title="side effect"></a>side effect</h5><p>Assignment is perhaps the most fundamental <strong>side effect</strong>: while the evaluation of an assignment may sometimes yield a value, what we really care about is the fact that it changes the value of a variable, thereby influencing the result of any later computation in<br>which the variable appears.</p>
<h5 id="References-and-Values"><a href="#References-and-Values" class="headerlink" title="References and Values"></a>References and Values</h5><p>there are some subtle but important differences in the semantics of assignment in different imperative languages. These differences are often invisible, because they do not affect the behavior of simple programs.</p>
<ul>
<li>值传递和引用传递</li>
<li>左值和右值</li>
</ul>
<h5 id="Boxing"><a href="#Boxing" class="headerlink" title="Boxing"></a>Boxing</h5><p>基础类型的拆装箱</p>
<h4 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h4><p>There are several reasons, however, why such initial values may be useful:</p>
<ul>
<li>静态变量需要初始化</li>
<li>编译器预分配初始化值优化（Java Integer预分配）</li>
<li>使用未初始化变量引起的问题</li>
</ul>
<p>It should be emphasized that initialization saves time <strong>only</strong> for variables that are <strong>statically allocated</strong>. </p>
<p>If a variable is not given an initial value explicitly in its declaration, the language may specify a <strong>default value</strong>. </p>
<h5 id="Dynamic-Checks"><a href="#Dynamic-Checks" class="headerlink" title="Dynamic Checks"></a>Dynamic Checks</h5><p>Instead of giving every uninitialized variable a default value, a language or implementation can choose to define the use of an uninitialized variable as a <strong>dynamic semantic error</strong>, and can catch these errors at run time. </p>
<h5 id="Definite-Assignment"><a href="#Definite-Assignment" class="headerlink" title="Definite Assignment"></a>Definite Assignment</h5><p>通过控制流分析静态检测未初始化变量：</p>
<p>This notion is based on the control flow of the program, and can be statically checked by the compiler.</p>
<h5 id="Constructors"><a href="#Constructors" class="headerlink" title="Constructors"></a>Constructors</h5><p>构造器默认初始化：</p>
<p>Many object-oriented languages (Java and C# among them) allow the programmer to define types for which initialization of <strong>dynamically allocated variables occurs automatically</strong>, even when <strong>no initial value is specified in the declaration</strong>.</p>
<h4 id="Ordering-within-Expressions"><a href="#Ordering-within-Expressions" class="headerlink" title="Ordering within Expressions"></a>Ordering within Expressions</h4><p>表达式内求值重要的原因：</p>
<ul>
<li>Side effects: 表达式内函数求值副作用</li>
<li>Code improvement: 求值顺序和编译器优化</li>
</ul>
<h4 id="Applying-Mathematical-Identities（数学恒等式）"><a href="#Applying-Mathematical-Identities（数学恒等式）" class="headerlink" title="Applying Mathematical Identities（数学恒等式）"></a>Applying Mathematical Identities（数学恒等式）</h4><p>表达式优化影响求值顺序会导致精度问题</p>
<h4 id="Short-Circuit-Evaluation（短路表达式）"><a href="#Short-Circuit-Evaluation（短路表达式）" class="headerlink" title="Short-Circuit Evaluation（短路表达式）"></a>Short-Circuit Evaluation（短路表达式）</h4><p>A compiler that performs <em>short-circuit evaluation</em> of Boolean expressions will generate code that skips the second half of both of these computations when the overall value can be determined from the first half.</p>
<h3 id="Structured-and-Unstructured-Flow"><a href="#Structured-and-Unstructured-Flow" class="headerlink" title="Structured and Unstructured Flow"></a>Structured and Unstructured Flow</h3><p>汇编中使用的goto（非结构化）编程被高级语言抛弃（结构化编程）</p>
<h4 id="Structured-Alternatives-to-goto"><a href="#Structured-Alternatives-to-goto" class="headerlink" title="Structured Alternatives to goto"></a>Structured Alternatives to goto</h4><p>Where once a goto might have been used to escape from the middle of a loop, most modern languages provide a <strong>break</strong> or <strong>exit</strong> statement for this purpose.</p>
<h4 id="Multilevel-Returns"><a href="#Multilevel-Returns" class="headerlink" title="Multilevel Returns"></a>Multilevel Returns</h4><p>return和 local goto都可以从当前子程序中返回，但是 nonlocal goto会破坏这种情况，如果直接goto到其他子程序中会破坏当前子程序堆栈，还需要立刻加载另一个子程序的堆栈。如果使用return这些都是在执行到return关键字时才发生的。</p>
<h4 id="Errors-and-Other-Exceptions"><a href="#Errors-and-Other-Exceptions" class="headerlink" title="Errors and Other Exceptions"></a>Errors and Other Exceptions</h4><p>需要Exceptions的原因：</p>
<blockquote>
<p>In a related and arguably more common situation, a deeply nested block or subroutine may discover that it is <strong>unable to proceed with its usual function</strong>, and moreover lacks the contextual information it would <strong>need to recover</strong> in any graceful way. </p>
</blockquote>
<p>As a structured alternative, many modern languages provide an <strong>exception-handling</strong> mechanism for convenient, nonlocal recovery from exceptions.</p>
<p>大多数语言只提供异常机制而不提供从多级调用中直接return的机制（想直接跳出多级调用只能抛异常）。</p>
<h4 id="Continuations"><a href="#Continuations" class="headerlink" title="Continuations"></a>Continuations</h4><p>The notion of nonlocal gotos that unwind the stack can be generalized by defining what are known as continuations.</p>
<p>call&#x2F;cc &#x3D;&gt; 控制流变换：</p>
<blockquote>
<p>在 Scheme 中，假设 call&#x2F;cc 捕捉到的 current continuation 为 cc(位于 lambda 中)，如果 cc 作为过程 直接或间接地被调用（即给它传值），call&#x2F;cc 会立即返回，返回值即为传入 cc 的值。即一旦 current continuation 被调用，控制流会跳到 call&#x2F;cc 处。因此，利用 call&#x2F;cc，我们可以摆脱顺序执行的限制，在程序中跳来跳去，非常灵活。</p>
</blockquote>
<h3 id="Sequencing"><a href="#Sequencing" class="headerlink" title="Sequencing"></a>Sequencing</h3><p>Like assignment, sequencing is central to imperative programming. It is the principal means of controlling <strong>the order in which side effects</strong> (e.g.,assignments) occur</p>
<p>顺序和副作用，无副作用函数可以进行指令重排提升性能。</p>
<h3 id="Selection"><a href="#Selection" class="headerlink" title="Selection"></a>Selection</h3><h4 id="Short-Circuited-Conditions"><a href="#Short-Circuited-Conditions" class="headerlink" title="Short-Circuited Conditions"></a>Short-Circuited Conditions</h4><p>虽然if else语句中包含一个布尔表达式，但是通常不需要将其结果解析出来放在寄存器中，而是拆分布尔表达式用来控制代码跳转（通过短路表达式来优化代码）。</p>
<h4 id="Case-Switch-Statements"><a href="#Case-Switch-Statements" class="headerlink" title="Case&#x2F;Switch Statements"></a>Case&#x2F;Switch Statements</h4><p>if else语句过长时可能会被优化成 switch&#x2F;case 语句（通过查表来优化代码性能）。</p>
<p>case查表也需要优化性能（如果静态值范围稀疏。。。）</p>
<h3 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h3><p>Iteration and recursion are the two mechanisms that allow a computer to perform similar operations repeatedly. </p>
<h4 id="Enumeration-Controlled-Loops（for循环）"><a href="#Enumeration-Controlled-Loops（for循环）" class="headerlink" title="Enumeration-Controlled Loops（for循环）"></a>Enumeration-Controlled Loops（for循环）</h4><p>在编译器生成代码时的一个可能的优化是预先计算迭代次数：<code>max([last-first+step]/step, 0)</code></p>
<p>枚举控制循环的几个设计问题：</p>
<ol>
<li>Can control enter or leave the loop in any way other than through the enumeration mechanism? &#x3D;&gt; break&#x2F;exit</li>
<li>What happens if the loop body modifies variables that were used to compute the end-of-loop bound? &#x3D;&gt; 不允许</li>
<li>What happens if the loop body modifies the index variable itself? &#x3D;&gt; 禁止在循环体内自己更新索引</li>
<li>Can the program read the index variable after the loop has completed, and if so, what will its value be? &#x3D;&gt; 循环结束后索引值是未定义的</li>
</ol>
<h4 id="Combination-Loops"><a href="#Combination-Loops" class="headerlink" title="Combination Loops"></a>Combination Loops</h4><p>自定义步长的for循环</p>
<h4 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h4><ul>
<li>range()</li>
<li>对象迭代器</li>
<li>惰性迭代流</li>
</ul>
<h3 id="Recursion-递归"><a href="#Recursion-递归" class="headerlink" title="Recursion 递归"></a>Recursion 递归</h3><h4 id="Iteration-and-Recursion"><a href="#Iteration-and-Recursion" class="headerlink" title="Iteration and Recursion"></a>Iteration and Recursion</h4><p>Iteration is in some sense the more “natural” of the two in imperative languages, because it is based on the repeated modification of variables. </p>
<p>Recursion is the more natural of the two in functional languages, because it does not change variables.</p>
<p>通常认为迭代比递归更高效，但是编译器优化也可以生成高效的递归代码，特别是尾递归代码的优化（不需要额外生成新的函数堆栈，可以重用当前函数的栈空间）</p>
<p>编译器也可以优化非尾递归代码，转换为尾递归代码执行。</p>
<p>使用递归思想思考代码（没有副作用的递归）可以产生更少的bug。</p>
<h4 id="Applicative-and-Normal-Order-Evaluation"><a href="#Applicative-and-Normal-Order-Evaluation" class="headerlink" title="Applicative- and Normal-Order Evaluation"></a>Applicative- and Normal-Order Evaluation</h4><p>Throughout the discussion so far we have assumed implicitly that arguments are <strong>evaluated before passing them to a subroutine</strong>. This need not be the case. It is possible to <strong>pass a representation of the unevaluated arguments to the subroutine</strong> instead, and to evaluate them only when (if) the value is actually needed.</p>
<p>惰性求值</p>
<h3 id="Nondeterminacy"><a href="#Nondeterminacy" class="headerlink" title="Nondeterminacy"></a>Nondeterminacy</h3><p>不确定的控制流（运行时才能确定）。</p>
<h3 id="Summary-and-Concluding-Remarks"><a href="#Summary-and-Concluding-Remarks" class="headerlink" title="Summary and Concluding Remarks"></a>Summary and Concluding Remarks</h3><p>在本章中，我们介绍了编程语言中发现的主要控制流形式：顺序、选择、迭代、程序抽象、递归、并发、异常处理和推测以及不确定性。顺序指定某些操作按顺序发生，一个接一个。选择表达了在两个或更多控制流替代方案之间的选择。迭代和递归是重复执行操作的两种方式。递归以自身的简单实例定义操作；它依赖于程序抽象。迭代重复一个操作以获得其副作用。顺序和迭代是命令式（特别是冯·诺依曼）编程的基础。递归是函数式编程的基础。不确定性允许程序员故意不指定控制流的某些方面。我们只简要地触及了并发；它将是第12章的主题。程序抽象（子程序）是第8章的主题。异常处理和推测将在第8.5节和第12.4.4节中介绍。</p>
<p>在我们对控制流机制的调查之前，我们讨论了表达式评估。我们考虑了左值和右值之间的区别，以及变量的值模型和引用模型之间的区别，在值模型中，变量是数据的命名容器，在引用模型中，变量是对数据对象的引用。我们考虑了表达式内的优先级、结合性和排序问题。我们检查了短路布尔评估及其通过跳转代码的实现，这既是一个影响表达式正确性的语义问题（其子部分并非总是定义良好），也是一个影响评估复杂布尔表达式所需时间的实现问题。</p>
<p>构造的发展受到了许多目标的驱动，包括编程的便利性、语义的优雅性、实现的便利性和运行时效率。在某些情况下，这些目标被证明是互补的。例如，我们已经看到短路评估既导致更快的代码，也（在许多情况下）导致更清晰的语义。同样地，为枚举控制循环的索引变量引入一个新的局部作用域，避免了循环后索引值的语义问题和（在某种程度上）潜在溢出的实现问题。</p>
<p>在其他情况下，语言语义的改进被认为值得在运行时效率上付出一点小代价。我们在迭代器的发展中看到了这一点：像许多形式的抽象一样，它们在许多情况下增加了适度的运行时成本（例如，与显式嵌入枚举集合的实现到循环的控制流中相比），但却带来了模块化、清晰性和代码重用机会的巨大回报。同样地，Java的开发者会辩称，对于许多应用程序来说，通过广泛的语义检查、标准格式的数值类型等提供的可移植性和安全性远比速度更重要。</p>
<p>在一些情况下，编译器技术的进步或设计者构建更复杂编译器的简单意愿，使得整合曾被认为过于昂贵的功能成为可能。Ada中的案例语句的标签范围要求编译器准备生成采用二进制搜索的代码。C++中的内联函数消除了在微小函数的低效率和宏的混乱语义之间选择的需要。异常（如我们将在第8.5.3节中看到）可以以这样一种方式实现，即在常见情况下（当它们不发生时）不会产生任何成本，但实现相当复杂。迭代器、装箱、泛型（第8.4节）和一级函数同样相当复杂，但在主流命令式语言中越来越常见。</p>
<p>一些实现技术（例如，重新排列表达式以发现公共子表达式，或者在找到可接受的选择后避免在不确定性构造中评估守卫）足够重要，以至于可以证明对程序员施加适度负担是合理的（例如，在必要时添加括号以避免溢出或确保数值稳定性，或确保守卫中的表达式没有副作用）。其他在语义上有用的机制（例如，惰性评估、续体或真正随机的不确定性）通常被认为足够复杂或昂贵，只在特殊情况下才值得使用（如果有的话）。</p>
<p>在相对原始的语言中，我们通常可以通过编程约定获得一些缺失功能的好处。例如，在早期的Fortran方言中，我们可以限制goto的使用，以模仿更现代语言的控制流。在没有短路评估的语言中，我们可以编写嵌套的选择语句。在没有迭代器的语言中，我们可以编写一组提供等效功能的子程序。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">MisakaTang</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/TangMisaka23001" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/third-party/pace.js"></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","mhchem":false,"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
